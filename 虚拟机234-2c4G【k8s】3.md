## 常用命令

```bash
# 水平扩展资源
kubectl autoscale deployment foo --min=2 --max=10
kubectl autoscale deployment nginx-deployment --min=2 --max=4
# 从Cronjob中复制一次性Job
kubectl create job --from=cronjob/<name of cronjob> <name of this run>
# 列出制定serviceaccount的权限
kubectl -n <namespace> auth can-i --list --as system:serviceaccount:<namespace>:<service account name>
# 注解资源标识 
# To add annotation
kubectl annotate <resource-type>/<resource-name> foo=bar
# To remove annotation
kubectl annotate <resource-type>/<resource-name> foo-
# 按时间字段排序列出所有的事件
kubectl get events --sort-by=".lastTimestamp"
# 列出集群中所有的Warning事件
kubectl get events -w --field-selector=type=Warning -A
# 列出实时观测的Pod，包含Event字段
kubectl get pods --watch --output-watch-events
# 列出API的原生完整内容
kubectl get --raw /apis/apps/v1
# Get metrics
kubectl get --raw /metrics
# 等待指定Pod启动
kubectl wait --for=condition=ready pod -l foo=bar
# 查询资源官方定义
kubectl explain pod.spec
# 根据标签列出所有符合的资源
kubectl get deployments,replicasets,pods,services --selector=hello=yourecute
# 映射远程端口到本地
kubectl port-forward svc/<service-name> <local-port>:<remote-port>
# 列出资源的所有环境变量
kubectl set env <resource>/<resource-name> --list
# 列出所有Pod并且显示运行在哪台主机上
kubectl get po -o=custom-columns=NODE:.spec.nodeName,NAME:.metadata.name
# 快速创建无状态服务资源的模板
kubectl create deploy nginx-deployment --image=nginx --dry-run=client -o yaml
# 按内存使用量列出所有Pod
kubectl top pods -A --sort-by='memory'
# 按app标签内容过滤列出所有Pod
kubectl get pods -l 'app in (foo,bar)'
# 获取上一次重启之前的Pod日志
kubectl logs <pod-name> --previous
# 自定义pod 格式化展示输出
kubectl get pods --all-namespaces -o custom-columns=NAMESPACE:.metadata.namespace,NAME:.metadata.name,HOSTNETWORK:.spec.hostNetwork --no-headers=true
```





# 案例

```bash
cat <<- 'eof' | k apply -f - -n default
apiVersion: v1
kind: ConfigMap
metadata:
  name: wp-cm
data:
  HOST: '172.17.0.2'
  USER: 'wp'
  PASSWORD: '123'
  NAME: 'db'
---
apiVersion: v1
kind: Pod
metadata:
  name: maria-pod
  labels:
    app: wordpress
    role: database
spec:
  containers:
  - image: mariadb:10
    name: maria
    imagePullPolicy: IfNotPresent
    ports:
    - containerPort: 3306

    envFrom:
    - prefix: 'MARIADB_'
      configMapRef:
        name: maria-cm
---
apiVersion: v1
kind: Pod
metadata:
  name: wp-pod
  labels:
    app: wordpress
    role: website
spec:
  containers:
  - image: wordpress:5
    name: wp-pod
    imagePullPolicy: IfNotPresent
    ports:
    - containerPort: 80
    envFrom:
    - prefix: 'WORDPRESS_DB_'
      configMapRef:
        name: wp-cm
---
eof
```

```bash
kubectl port-forward wp-pod 8080:80 &
```

````bash
server {
  listen 80;
  default_type text/html;

  location / {
      proxy_http_version 1.1;
      proxy_set_header Host $host;
      proxy_pass http://127.0.0.1:8080;
  }
}
````

```bash
docker run -d --rm \
    --net=host \
    -v /tmp/proxy.conf:/etc/nginx/conf.d/default.conf \
    nginx:alpine
```

```bash
写一下第2题吧解题步骤：
首先如果我们把docker 形式改成pod形式这里存在两个问题（1）网络问题，（2）nginx配置文件加载问题，
第一个问题k8s的插件会处理节点内以及节点间网络通信问题，这个我们这里暂时不需要考虑，
那么需要我们处理的就是配置文件问题：这里我们可以用多个方法处理
   a: pod挂载宿主机目录，把配置文件放到宿主机目录下，容器启动挂载
   b: 使用我们学过的configMap
   c：使用pv、pvc 这个后面老师应该会讲到
这里我门就使用第二种方法，也是评论里使用最多的方法：
yml文件如下：
    ngx-cm.yml

apiVersion: v1
kind: ConfigMap
metadata:
  name: ngx-cm
data:
  nginx.conf: |
    server {
      listen 8080;
      #default_type text/html;

      location / {
        proxy_http_version 1.1;
        proxy_set_header Host $host;
        proxy_pass http://172.17.0.9:80;
      }
    }

nginx.yml:

apiVersion: v1
kind: Pod
metadata:
  name: ngx-pod
  labels:
    env: demo
    owner: ant

spec:
  volumes:
    - name: nginx-conf
      configMap:
        name: ngx-cm
        items:
        - key: nginx.conf
          path: default.conf
  containers:
  - image: nginx:alpine
    name: ngx
    volumeMounts:
      - name: nginx-conf
        mountPath: /etc/nginx/conf.d
    ports:
    - containerPort: 8080

然后使用 kubectl apply -f nginx.yml 创建pod，但是这个时候由于k8s节点还是一个隔离环境，所以我们还是无法访问，
所以我们要在网页观察到具体的网页内容，还是要再用docker创建一层nginx代理，server 内容如下：
server {
  listen 80;
  default_type text/html;

  location / {
      proxy_http_version 1.1;
      proxy_set_header Host $host;
      proxy_pass http://127.0.0.1:8888;
  }
}

使用 docker run -d --rm --net=host -v /home/ant/kubernetes/pod/nginx-conf/nginx.conf:/etc/nginx/conf.d/default.conf nginx:alpine
启动，
然后使用 kubectl port-forward ngx-pod 8888:8080 & 做转发

访问 http://192.168.56.208/ 正常访问
```

Metrics Server 提供：

- 一个适用于大多数集群的 Deployment
- 快速自动缩放，每 15 秒收集一次指标。
- 资源效率，为集群中的每个节点使用 1 毫秒的 CPU 内核和 2MB 内存。
- 可扩展支持多达 5000 个节点集群。

# 创建 Metrics Server 证书（可选）

------

> 如果 Metrics Server 不使用外部 SSL 证书的话则直接跳过此步，Metrics Server 会自动生成自签证书

进入集群 CA 证书所在目录，本文以 `/root/k8s-cert/` 为例，创建 `metrics-server-csr.json` 文件

```
cd /root/k8s-cert
cat > metrics-server-csr.json << EOF
{
  "CN": "metrics-server",
  "hosts": [""],
  "key": {
    "algo": "rsa",
    "size": 2048
  },
  "names": [
    {
      "C": "CN",
      "L": "ShenZhen",
      "ST": "ShenZhen",
      "O": "k8s",
      "OU": "System"
    }
  ]
}
EOF
```

为 Metrics Server 生成证书

```
cfssl gencert -ca=ca.pem -ca-key=ca-key.pem -config=ca-config.json -profile=kubernetes metrics-server-csr.json | cfssljson -bare metrics-server
```

创建 Metrics Server 的 Secret，Secret 为 `metrics-server-certs`

```
kubectl create secret generic metrics-server-certs --from-file=/root/k8s-cert/metrics-server-key.pem --from-file=/root/k8s-cert/metrics-server.pem -n kube-system
kubectl get secret -n kube-system | grep metrics-server-certs
kubectl get secret metrics-server-certs -n kube-system  -o yaml
```

# 安装 Metrics Server

------

> 以安装 v0.5.0 为例

访问 https://github.com/kubernetes-sigs/metrics-server/tree/master，并选择相应 Tags

[![img](https://img.koenli.com/Metrics%20Server%E5%AE%89%E8%A3%85_1.png)](https://img.koenli.com/Metrics Server安装_1.png)

## 使用外部 SSL 证书

在 `Installation` 章节获取对应版本的安装命令，复制命令中的 URL，执行以下命令下载 YAML

[![img](https://img.koenli.com/Metrics%20Server%E5%AE%89%E8%A3%85_2.png)](https://img.koenli.com/Metrics Server安装_2.png)

```
cd /root/
wget https://github.com/kubernetes-sigs/metrics-server/releases/latest/download/components.yaml
```

编辑 `components.yaml`，新增如下注释部分内容。`secretName` 与前面创建的 Metrics Server 的 Secret 名称对应

```
...
---
apiVersion: apps/v1
kind: Deployment
metadata:
  labels:
    k8s-app: metrics-server
  name: metrics-server
  namespace: kube-system
spec:
  selector:
    matchLabels:
      k8s-app: metrics-server
  strategy:
    rollingUpdate:
      maxUnavailable: 0
  template:
    metadata:
      labels:
        k8s-app: metrics-server
    spec:
      containers:
      - args:
        - --cert-dir=/tmp
        - --secure-port=443
        - --kubelet-preferred-address-types=InternalIP,ExternalIP,Hostname
        - --kubelet-use-node-status-port
        - --metric-resolution=15s
        # 新增配置证书路径
        - --tls-cert-file=/certs/metrics-server.pem
        - --tls-private-key-file=/certs/metrics-server-key.pem
        image: k8s.gcr.io/metrics-server/metrics-server:v0.5.0
        imagePullPolicy: IfNotPresent
        livenessProbe:
          failureThreshold: 3
          httpGet:
            path: /livez
            port: https
            scheme: HTTPS
          periodSeconds: 10
        name: metrics-server
        ports:
        - containerPort: 443
          name: https
          protocol: TCP
        readinessProbe:
          failureThreshold: 3
          httpGet:
            path: /readyz
            port: https
            scheme: HTTPS
          initialDelaySeconds: 20
          periodSeconds: 10
        resources:
          requests:
            cpu: 100m
            memory: 200Mi
        securityContext:
          readOnlyRootFilesystem: true
          runAsNonRoot: true
          runAsUser: 1000
        volumeMounts:
        - mountPath: /tmp
          name: tmp-dir
        # 新增配置secret挂载路径
        - name: metrics-server-certs
          mountPath: /certs
      nodeSelector:
        kubernetes.io/os: linux
      priorityClassName: system-cluster-critical
      serviceAccountName: metrics-server
      volumes:
      - emptyDir: {}
        name: tmp-dir
      # 新增挂载secret
      - name: metrics-server-certs
        secret:
          secretName: metrics-server-certs
...
```

应用 YAML

```
kubectl apply -f /root/components.yaml
```

## 不使用外部 SSL 证书

在 `Installation` 章节获取对应版本的安装命令，复制命令中的 URL，执行以下命令下载并应用 YAML

> **说明**
> 先下载 YAML 文件再进行 apply 方便后续对配置进行修改

[![img](https://img.koenli.com/Metrics%20Server%E5%AE%89%E8%A3%85_2.png)](https://img.koenli.com/Metrics Server安装_2.png)

```
cd /root/
wget https://github.com/kubernetes-sigs/metrics-server/releases/latest/download/components.yaml
kubectl apply -f /root/components.yaml
```

# 遇到的问题

------

应用完 YAML 文件后执行 `kubectl get pod -n kube-system `发现 Metrics Server 的 Pod 一直处于未就绪状态

[![img](https://img.koenli.com/Metrics%20Server%E5%AE%89%E8%A3%85_3.png)](https://img.koenli.com/Metrics Server安装_3.png)

查看 Pod 日志出现如下错误日志

```
# kubectl logs -n kube-system metrics-server-68bf9d85fb-gbf5x
E0825 09:20:05.767459       1 scraper.go:139] "Failed to scrape node" err="Get \"https://10.211.55.7:10250/stats/summary?only_cpu_and_memory=true\": x509: cannot validate certificate for 10.211.55.7 because it doesn't contain any IP SANs" node="easyk8s1"
E0825 09:20:05.769695       1 scraper.go:139] "Failed to scrape node" err="Get \"https://10.211.55.8:10250/stats/summary?only_cpu_and_memory=true\": x509: cannot validate certificate for 10.211.55.8 because it doesn't contain any IP SANs" node="easyk8s2"
E0825 09:20:05.785750       1 scraper.go:139] "Failed to scrape node" err="Get \"https://10.211.55.9:10250/stats/summary?only_cpu_and_memory=true\": x509: cannot validate certificate for 10.211.55.9 because it doesn't contain any IP SANs" node="easyk8s3"
```

原因是 Metrics Server 会去连接各 Node 节点上 Kubelet 的 10250 端口以获取信息，但是 Kubelet 的 10250 端口使用的是 HTTPS 协议，连接需要验证 TLS 证书，此问题有如下两种解决方法。

> 方法一：不验证 Kubelet 提供的服务证书的 CA（生产环境不推荐）

编辑 `components.yaml`，新增 `--kubelet-insecure-tls` 参数

```
...
    spec:
      containers:
      - args:
        - --cert-dir=/tmp
        - --secure-port=443
        - --kubelet-preferred-address-types=InternalIP,ExternalIP,Hostname
        - --kubelet-use-node-status-port
        - --metric-resolution=15s
        - --kubelet-insecure-tls    # 新增此行配置
...
```

重新应用 YAML

```
kubectl delete -f /root/components.yaml
kubectl apply -f /root/components.yaml
```

稍等片刻，再次执行 `kubectl get pod -n kube-system` 确认 Metrics Server 的 Pod 是否就绪，然后执行 `kubectl top node` 和 `kubectl top pod -A` 看是否可正常获取资源指标。

> 方法二：开启 Bootstrap 中的服务证书申请流程（生产环境推荐）

在所有 Node 节点编辑 Kubelet 的 `config.yaml` 文件（kubeadm 方式部署集群为 `/var/lib/kubelet/config.yaml`，二进制方式部署集群以实际环境为准，本文以 `/opt/kubernetes/cfg/kubelet-config.yml` 为例），在末尾加入一行 `serverTLSBootstrap: true`

```
# kubeadm方式部署集群
# vim var/lib/kubelet/config.yaml
...
syncFrequency: 0s
volumeStatsAggPeriod: 0s
serverTLSBootstrap: true    # 新增此行配置

# 二进制方式部署集群
# vim /opt/kubernetes/cfg/kubelet-config.yml
...
maxOpenFiles: 1000000
maxPods: 110
serverTLSBootstrap: true    # 新增此行配置
```

重启 Kubelet

```
systemctl restart kubelet
systemctl status kubelet
```

重启 Kubelet 后会发现出现了新的 CSR

```
# kubectl  get csr
NAME        AGE    SIGNERNAME                      REQUESTOR              CONDITION
csr-5ffk2   29s    kubernetes.io/kubelet-serving   system:node:easyk8s2   Pending
csr-dh8gp   18s    kubernetes.io/kubelet-serving   system:node:easyk8s3   Pending
csr-jrgx5   107s   kubernetes.io/kubelet-serving   system:node:easyk8s1   Pending
```

如果使用 `base64 -d` 对 csr 的 request 字段做解码，并查看其请求内容的话，会发现证书请求中带有了 SAN 记录。

```
# 任取一个csr，获取其request值
kubectl get   csr csr-5ffk2  -o yaml
...
  request: LS0tLS1CRUdJTiBDRVJUSUZJQ0FURSBSRVFVRVNULS0tLS0KTUlJQkhqQ0J4QUlCQURBMk1SVXdFd1lEVlFRS0V3eHplWE4wWlcwNmJtOWtaWE14SFRBYkJnTlZCQU1URkhONQpjM1JsYlRwdWIyUmxPbVZoYzNsck9ITXlNRmt3RXdZSEtvWkl6ajBDQVFZSUtvWkl6ajBEQVFjRFFnQUVaYVhvCmxKeS9lRktnKzh6UUpLUTZsWTJXY1RLdzBFVm9MTzJlZUlKcUNVcUlCTFBZeU9iMGd5Y3Z6MHJkdy81SGI1WWYKc1h0YWVvNnk1aUhVemF0TEpxQXNNQ29HQ1NxR1NJYjNEUUVKRGpFZE1Cc3dHUVlEVlIwUkJCSXdFSUlJWldGegplV3M0Y3pLSEJBclROd2d3Q2dZSUtvWkl6ajBFQXdJRFNRQXdSZ0loQU8yN0NrRUJteHZWTFBXTXdXR3FvQ3dRCnJOYkNMS29ERHlsWDJlMTZveUtEQWlFQTFNeUNXL2VkNVNnSHJBVGtyTFh6VE5aU3RmV2lCenNmSW5Vcm1LeFAKbFo4PQotLS0tLUVORCBDRVJUSUZJQ0FURSBSRVFVRVNULS0tLS0K
...

# 解码并重定向到csr.pem
echo -n "LS0tLS1CRUdJTiBDRVJUSUZJQ0FURSBSRVFVRVNULS0tLS0KTUlJQkhqQ0J4QUlCQURBMk1SVXdFd1lEVlFRS0V3eHplWE4wWlcwNmJtOWtaWE14SFRBYkJnTlZCQU1URkhONQpjM1JsYlRwdWIyUmxPbVZoYzNsck9ITXlNRmt3RXdZSEtvWkl6ajBDQVFZSUtvWkl6ajBEQVFjRFFnQUVaYVhvCmxKeS9lRktnKzh6UUpLUTZsWTJXY1RLdzBFVm9MTzJlZUlKcUNVcUlCTFBZeU9iMGd5Y3Z6MHJkdy81SGI1WWYKc1h0YWVvNnk1aUhVemF0TEpxQXNNQ29HQ1NxR1NJYjNEUUVKRGpFZE1Cc3dHUVlEVlIwUkJCSXdFSUlJWldGegplV3M0Y3pLSEJBclROd2d3Q2dZSUtvWkl6ajBFQXdJRFNRQXdSZ0loQU8yN0NrRUJteHZWTFBXTXdXR3FvQ3dRCnJOYkNMS29ERHlsWDJlMTZveUtEQWlFQTFNeUNXL2VkNVNnSHJBVGtyTFh6VE5aU3RmV2lCenNmSW5Vcm1LeFAKbFo4PQotLS0tLUVORCBDRVJUSUZJQ0FURSBSRVFVRVNULS0tLS0K" | base64 -d > /root/csr.pem

# 查看其请求内容
# openssl req -in /root/csr.pem -noout -text
Certificate Request:
    Data:
        Version: 0 (0x0)
        Subject: O=system:nodes, CN=system:node:easyk8s2
        Subject Public Key Info:
            Public Key Algorithm: id-ecPublicKey
                Public-Key: (256 bit)
                pub: 
                    04:65:a5:e8:94:9c:bf:78:52:a0:fb:cc:d0:24:a4:
                    3a:95:8d:96:71:32:b0:d0:45:68:2c:ed:9e:78:82:
                    6a:09:4a:88:04:b3:d8:c8:e6:f4:83:27:2f:cf:4a:
                    dd:c3:fe:47:6f:96:1f:b1:7b:5a:7a:8e:b2:e6:21:
                    d4:cd:ab:4b:26
                ASN1 OID: prime256v1
                NIST CURVE: P-256
        Attributes:
        Requested Extensions:
            X509v3 Subject Alternative Name: 
                DNS:easyk8s2, IP Address:10.211.55.8
    Signature Algorithm: ecdsa-with-SHA256
         30:46:02:21:00:ed:bb:0a:41:01:9b:1b:d5:2c:f5:8c:c1:61:
         aa:a0:2c:10:ac:d6:c2:2c:aa:03:0f:29:57:d9:ed:7a:a3:22:
         83:02:21:00:d4:cc:82:5b:f7:9d:e5:28:07:ac:04:e4:ac:b5:
         f3:4c:d6:52:b5:f5:a2:07:3b:1f:22:75:2b:98:ac:4f:95:9f
```

授权 csr

```
# kubectl certificate approve csr-5ffk2 csr-dh8gp csr-jrgx5
certificatesigningrequest.certificates.k8s.io/csr-5ffk2 approved
certificatesigningrequest.certificates.k8s.io/csr-dh8gp approved
certificatesigningrequest.certificates.k8s.io/csr-jrgx5 approved
```

通过之后，Kubelet 就有了使用 API Server 的 CA 签发的证书了。

稍等片刻，再次执行 `kubectl get pod -n kube-system` 确认 Metrics Server 的 Pod 是否就绪，然后执行 `kubectl top node` 和 `kubectl top pod -A` 看是否可正常获取资源指标。

